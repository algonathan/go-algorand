// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"wJvd7QAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
