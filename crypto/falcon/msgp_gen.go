package falcon

// Code generated by github.com/algorand/msgp DO NOT EDIT.

import (
	cfalcon "github.com/algorand/falcon"
	"github.com/algorand/msgp/msgp"
)

// The following msgp objects are implemented in this file:
// PrivateKey
//      |-----> (*) MarshalMsg
//      |-----> (*) CanMarshalMsg
//      |-----> (*) UnmarshalMsg
//      |-----> (*) CanUnmarshalMsg
//      |-----> (*) Msgsize
//      |-----> (*) MsgIsZero
//
// PublicKey
//     |-----> (*) MarshalMsg
//     |-----> (*) CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> (*) Msgsize
//     |-----> (*) MsgIsZero
//
// Seed
//   |-----> (*) MarshalMsg
//   |-----> (*) CanMarshalMsg
//   |-----> (*) UnmarshalMsg
//   |-----> (*) CanUnmarshalMsg
//   |-----> (*) Msgsize
//   |-----> (*) MsgIsZero
//
// Signature
//     |-----> MarshalMsg
//     |-----> CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> Msgsize
//     |-----> MsgIsZero
//
// Signer
//    |-----> (*) MarshalMsg
//    |-----> (*) CanMarshalMsg
//    |-----> (*) UnmarshalMsg
//    |-----> (*) CanUnmarshalMsg
//    |-----> (*) Msgsize
//    |-----> (*) MsgIsZero
//
// Verifier
//     |-----> (*) MarshalMsg
//     |-----> (*) CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> (*) Msgsize
//     |-----> (*) MsgIsZero
//

// MarshalMsg implements msgp.Marshaler
func (z *PrivateKey) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *PrivateKey) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*PrivateKey)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PrivateKey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *PrivateKey) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*PrivateKey)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PrivateKey) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (cfalcon.PrivateKeySize * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *PrivateKey) MsgIsZero() bool {
	return (*z) == (PrivateKey{})
}

// MarshalMsg implements msgp.Marshaler
func (z *PublicKey) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *PublicKey) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*PublicKey)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PublicKey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *PublicKey) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*PublicKey)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PublicKey) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (cfalcon.PublicKeySize * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *PublicKey) MsgIsZero() bool {
	return (*z) == (PublicKey{})
}

// MarshalMsg implements msgp.Marshaler
func (z *Seed) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *Seed) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Seed)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Seed) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *Seed) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Seed)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Seed) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (FalconSeedSize * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Seed) MsgIsZero() bool {
	return (*z) == (Seed{})
}

// MarshalMsg implements msgp.Marshaler
func (z Signature) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, []byte(z))
	return
}

func (_ Signature) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(Signature)
	if !ok {
		_, ok = (z).(*Signature)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Signature) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 []byte
		var zb0002 int
		zb0002, err = msgp.ReadBytesBytesHeader(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > FalconMaxSignatureSize {
			err = msgp.ErrOverflow(uint64(zb0002), uint64(FalconMaxSignatureSize))
			return
		}
		zb0001, bts, err = msgp.ReadBytesBytes(bts, []byte((*z)))
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = Signature(zb0001)
	}
	o = bts
	return
}

func (_ *Signature) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Signature)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Signature) Msgsize() (s int) {
	s = msgp.BytesPrefixSize + len([]byte(z))
	return
}

// MsgIsZero returns whether this is a zero value
func (z Signature) MsgIsZero() bool {
	return len(z) == 0
}

// MarshalMsg implements msgp.Marshaler
func (z *Signer) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(2)
	var zb0003Mask uint8 /* 3 bits */
	if (*z).PublicKey == (PublicKey{}) {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).PrivateKey == (PrivateKey{}) {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "pk"
			o = append(o, 0xa2, 0x70, 0x6b)
			o = msgp.AppendBytes(o, ((*z).PublicKey)[:])
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "sk"
			o = append(o, 0xa2, 0x73, 0x6b)
			o = msgp.AppendBytes(o, ((*z).PrivateKey)[:])
		}
	}
	return
}

func (_ *Signer) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Signer)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Signer) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = msgp.ReadExactBytes(bts, ((*z).PublicKey)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PublicKey")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = msgp.ReadExactBytes(bts, ((*z).PrivateKey)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PrivateKey")
				return
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = Signer{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "pk":
				bts, err = msgp.ReadExactBytes(bts, ((*z).PublicKey)[:])
				if err != nil {
					err = msgp.WrapError(err, "PublicKey")
					return
				}
			case "sk":
				bts, err = msgp.ReadExactBytes(bts, ((*z).PrivateKey)[:])
				if err != nil {
					err = msgp.WrapError(err, "PrivateKey")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *Signer) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Signer)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Signer) Msgsize() (s int) {
	s = 1 + 3 + msgp.ArrayHeaderSize + (cfalcon.PublicKeySize * (msgp.ByteSize)) + 3 + msgp.ArrayHeaderSize + (cfalcon.PrivateKeySize * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Signer) MsgIsZero() bool {
	return ((*z).PublicKey == (PublicKey{})) && ((*z).PrivateKey == (PrivateKey{}))
}

// MarshalMsg implements msgp.Marshaler
func (z *Verifier) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0002Len := uint32(1)
	var zb0002Mask uint8 /* 2 bits */
	if (*z).PublicKey == (PublicKey{}) {
		zb0002Len--
		zb0002Mask |= 0x2
	}
	// variable map header, size zb0002Len
	o = append(o, 0x80|uint8(zb0002Len))
	if zb0002Len != 0 {
		if (zb0002Mask & 0x2) == 0 { // if not empty
			// string "k"
			o = append(o, 0xa1, 0x6b)
			o = msgp.AppendBytes(o, ((*z).PublicKey)[:])
		}
	}
	return
}

func (_ *Verifier) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Verifier)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Verifier) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = msgp.ReadExactBytes(bts, ((*z).PublicKey)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PublicKey")
				return
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = Verifier{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "k":
				bts, err = msgp.ReadExactBytes(bts, ((*z).PublicKey)[:])
				if err != nil {
					err = msgp.WrapError(err, "PublicKey")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *Verifier) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Verifier)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Verifier) Msgsize() (s int) {
	s = 1 + 2 + msgp.ArrayHeaderSize + (cfalcon.PublicKeySize * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Verifier) MsgIsZero() bool {
	return ((*z).PublicKey == (PublicKey{}))
}
